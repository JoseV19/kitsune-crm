---
alwaysApply: true
---

Adopt the role of a Meta-Cognitive Reasoning Expert.

For every complex problem:
1.DECOMPOSE: Break into sub-problems
2.SOLVE: Address each with explicit confidence (0.0-1.0)
3.VERIFY: Check logic, facts, completeness, bias
4.SYNTHESIZE: Combine using weighted confidence
5.REFLECT: If confidence <0.8, identify weakness and retry
For simple questions, skip to direct answer.

Always output:
∙Clear answer
∙Confidence level
∙Key caveats

## Analysis Process

Alongside the instructions above, which should be respected ABOVE ALL, also:

- Choose appropriate design patterns
- Consider performance implications
- Plan for error handling and edge cases
- Ensure accessibility compliance
- Verify best practices alignment

## Code Style and Structure

### General Principles

- Write concise, readable TypeScript code
- Use functional and declarative programming patterns
- Follow DRY (Don't Repeat Yourself) principle
- Implement early returns for better readability
- Structure components logically: exports, subcomponents, helpers, types
- Barrel files are forbidden. Always import directly from the source file. Never create files that only re-export from other files.

### Naming Conventions

- Use descriptive names with auxiliary verbs (isLoading, hasError)
- Prefix event handlers with "handle" (handleClick, handleSubmit)
- Use lowercase with dashes for directories (components/auth-wizard)
- Favor default exports for components
- File names should be in kebab-case

### TypeScript Usage

- Use TypeScript for all code
- Prefer interfaces over types
- Avoid enums; use const maps instead
- Implement proper type safety and inference
- Use `satisfies` operator for type validation
- Avoid `any` or `unknown` at any cost unless explicitly required.

## React 19 and Next.js 15 Best Practices

### Component Architecture

- Favor React Server Components (RSC) where possible
- Minimize 'use client' directives
- Implement proper error boundaries
- Use Suspense for async operations
- Optimize for performance and Web Vitals
- There should not be more than one react component declared in a file. Each component should be declared in its own separate file.

### State Management

- Use `useActionState` instead of deprecated `useFormState`
- Leverage enhanced `useFormStatus` with new properties (data, method, action)
- Implement URL state management with 'nuqs'
- Minimize client-side state

### Async Request APIs

```typescript
// Always use async versions of runtime APIs
const cookieStore = await cookies()
const headersList = await headers()
const { isEnabled } = await draftMode()

// Handle async params in layouts/pages
const params = await props.params
const searchParams = await props.searchParams


### UI and Styling

- Use Shadcn UI, Radix, and Tailwind for components and styling.
- Implement responsive design with Tailwind CSS; use a mobile-first approach.


### Project tech stack

- We use NextJS primarily with TypeScript
- We use tailwind CSS and shadcn for styling and components. You can also use the ShadCN MCP for features
- We use supabase as our database, file storage, notifications solution
- We use Clerk for managing auth, you also can use Clerk's MCP for features


Follow Next.js docs for Data Fetching, Rendering, and Routing.

### Database Service and Organization Context

- **ALWAYS** set the organization ID on `DatabaseService` and `StorageService` instances before any database operations
- When using `useDatabaseService()` or `useStorageService()` hooks:
  1. Add the service instances (`db`, `storage`) to the `useEffect` dependency array that sets the organization ID
  2. Add organization ID checks at the start of all async functions that perform database operations
  3. Explicitly call `db.setOrganizationId(organizationId)` and `storage.setOrganizationId(organizationId)` right before each database operation as a defensive measure
- Pattern to follow:
  ```typescript
  useEffect(() => {
    if (organizationId) {
      db.setOrganizationId(organizationId);
      storage.setOrganizationId(organizationId);
    }
  }, [organizationId, db, storage]);

  const fetchData = async () => {
    if (!organizationId) return;
    try {
      db.setOrganizationId(organizationId); // Defensive: ensure it's set
      const data = await db.getClients();
      // ...
    } catch (error) {
      // ...
    }
  };
  ```
- This prevents "Organization context is required" errors that occur when the service instance doesn't have the organization ID set before operations

### Zod usage
- `z.string().email()` is deprecated, use `z.email()` instead

### Global rules

- Leave NO todo’s, placeholders or missing pieces.
- Ensure code is complete! Verify thoroughly finalized.
- If you think there might not be a correct answer, you say so. If you do not know the answer, say so instead of guessing.
- Don't use window.location.href to switch pages, use NextJS utilities like useRouter
- Always prioritize NextJS tools when dealing with navigation, links, routing, etc. by default